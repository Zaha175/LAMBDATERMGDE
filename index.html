<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î›(z) Dynamik im GDE-Modell</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.0"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        heading: '#0A2472',
                        accent1: '#5D9CDE',
                        accent2: '#DE5D9C',
                        accent3: '#9CDE5D',
                        lightAccent: '#f0f4ff',
                        darkAccent: '#192339',
                        phantom: '#ef4444',
                        quintessence: '#3b82f6',
                        cosmological: '#10b981',
                        desi: '#f97316', // Orange fÃ¼r DESI-Daten
                        temperature: '#8b5cf6', // Violett fÃ¼r Temperatur-Term
                        entropy: '#db2777', // Pink fÃ¼r Entropie-Term
                    },
                },
            },
        }

        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>
    <style>
        .dark {
            color-scheme: dark;
        }
        .dark .math {
            color: #e2e8f0;
        }
        .equation-container {
            position: relative;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(93, 156, 222, 0.05);
            border-left: 3px solid #5D9CDE;
            border-radius: 0.5rem;
        }
        .equation-content {
             padding-right: 2rem;
        }
        .chart-container {
            position: relative;
            height: 40vh;
            width: 100%;
            margin-bottom: 1rem;
        }
        .small-chart-container {
            position: relative;
            height: 30vh;
            width: 100%;
            margin-bottom: 1rem;
        }
        .mini-chart-container {
            position: relative;
            height: 120px;
            width: 100%;
            margin-bottom: 0.5rem;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #e2e8f0;
            border-radius: 5px;
            outline: none;
            margin: 10px 0;
        }
        .dark input[type="range"] {
            background: #4b5563;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
            transition: background 0.15s ease;
        }
        .dark input[type="range"]::-webkit-slider-thumb {
            background: #93c5fd;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #5D5CDE;
            cursor: pointer;
            border: none;
            transition: background 0.15s ease;
        }
        .dark input[type="range"]::-moz-range-thumb {
            background: #93c5fd;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #4e4eba;
            transform: scale(1.1);
        }
        .dark input[type="range"]::-webkit-slider-thumb:hover {
            background: #818cf8;
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: #4e4eba;
            transform: scale(1.1);
        }
        .dark input[type="range"]::-moz-range-thumb:hover {
            background: #818cf8;
        }
        .parameter-card {
            border-left: 4px solid #5D5CDE;
            transition: all 0.3s ease;
        }
        .parameter-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .glow-animation {
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            from {
                box-shadow: 0 0 5px -5px #5D5CDE;
            }
            to {
                box-shadow: 0 0 15px 0px #5D5CDE;
            }
        }
        .formula-explainer {
            position: relative;
        }
        .formula-tooltip {
            visibility: hidden;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4338ca;
            color: white;
            text-align: center;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            z-index: 10;
            width: max-content;
            max-width: 20rem;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .formula-tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #4338ca transparent transparent transparent;
        }
        .formula-explainer:hover .formula-tooltip {
            visibility: visible;
            opacity: 1;
        }
        .term-highlight {
            position: relative;
            padding: 2px 4px;
            border-radius: 4px;
            cursor: help;
        }
        #loading-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 4px;
            background: linear-gradient(to right, #5D5CDE, #DE5D9C);
            z-index: 9999;
            transition: width 0.3s ease;
        }
        .highlight-box {
            position: relative;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
            overflow: hidden;
        }
        .highlight-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
        }
        .temperature-box {
            background-color: rgba(139, 92, 246, 0.1);
        }
        .temperature-box::before {
            background-color: #8b5cf6;
        }
        .dark .temperature-box {
            background-color: rgba(139, 92, 246, 0.2);
        }
        .entropy-box {
            background-color: rgba(219, 39, 119, 0.1);
        }
        .entropy-box::before {
            background-color: #db2777;
        }
        .dark .entropy-box {
            background-color: rgba(219, 39, 119, 0.2);
        }
        .combined-box {
            background-color: rgba(93, 92, 222, 0.1);
        }
        .combined-box::before {
            background-color: #5D5CDE;
        }
        .dark .combined-box {
            background-color: rgba(93, 92, 222, 0.2);
        }
        .pulse-highlight {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(93, 92, 222, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(93, 92, 222, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(93, 92, 222, 0);
            }
        }
        .data-point {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 0.5rem;
            background-color: rgba(249, 115, 22, 0.1);
            border: 1px solid #f97316;
            font-weight: 600;
            color: #c2410c;
        }
        .dark .data-point {
            background-color: rgba(249, 115, 22, 0.2);
            color: #fb923c;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-white to-lightAccent dark:from-gray-900 dark:to-darkAccent text-gray-800 dark:text-gray-100 transition-colors duration-200">
    <div id="loading-bar"></div>
    
    <div class="container mx-auto px-4 py-8 max-w-5xl shadow-lg rounded-lg bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm">
        <header class="flex flex-col md:flex-row justify-between items-center mb-8 relative">
            <div class="absolute -top-8 left-0 right-0 h-2 bg-gradient-to-r from-accent1 via-accent2 to-accent3 rounded-full"></div>
            <div class="text-center md:text-left">
                <h1 class="text-2xl md:text-3xl font-bold mb-2 bg-clip-text text-transparent bg-gradient-to-r from-heading to-accent1 dark:from-accent1 dark:to-accent2">Î›(z) Dynamik im GDE-Modell</h1>
                <h2 class="text-lg md:text-xl font-semibold text-heading dark:text-accent1">Thermodynamische Kopplung der Dunklen Energie</h2>
            </div>
            <button id="darkModeToggle" class="mt-4 md:mt-0 px-4 py-2 rounded-full bg-heading text-white dark:bg-accent1 hover:bg-opacity-90 transition-colors duration-200">
                <span id="darkModeIcon">ðŸŒ™</span> <span id="darkModeText">Dark Mode</span>
            </button>
        </header>

        <div class="bg-blue-50 dark:bg-blue-900/30 p-4 rounded-lg mb-8">
            <h3 class="text-xl font-semibold mb-2 text-blue-800 dark:text-blue-300">Was ist der dynamische Lambda-Term?</h3>
            <p class="text-base">
                Im Standardmodell der Kosmologie (Î›CDM) ist Î› eine Konstante. Im GDE-Modell ist Î›(z) stattdessen 
                eine dynamische Funktion, die an thermodynamische GrÃ¶ÃŸen gekoppelt ist: die Temperatur der kosmischen 
                Hintergrundstrahlung und die Entropie kosmischer Strukturen.
            </p>
        </div>

        <section class="bg-white/80 dark:bg-gray-800/80 p-6 rounded-xl shadow-lg mb-10">
            <h3 class="text-xl font-semibold mb-6 text-indigo-600 dark:text-indigo-400 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                </svg>
                Die fundamentale Î›(z)-Gleichung im GDE-Modell
            </h3>
            
            <div class="equation-container glow-animation bg-blue-50/80 dark:bg-blue-900/20">
                <div class="equation-content text-center">
                    \[ \Lambda(z) = \Lambda_0 \cdot \left( \frac{T_0}{T_{\mathrm{CMB}}(z)} \right)^{\alpha(z)} \cdot \left(1 + \beta \cdot \frac{S_{\mathrm{Struktur}}(z)}{S_{\mathrm{Struktur}}(0)} \right) \]
                </div>
            </div>
            
            <div class="mt-4 grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="bg-indigo-50 dark:bg-indigo-900/20 p-3 rounded-lg">
                    <h4 class="font-semibold mb-1 text-indigo-700 dark:text-indigo-300">Î±â‚€ = -0.57</h4>
                    <p class="text-sm">
                        Basis-Exponent der thermodynamischen Kopplung
                    </p>
                </div>
                <div class="bg-indigo-50 dark:bg-indigo-900/20 p-3 rounded-lg">
                    <h4 class="font-semibold mb-1 text-indigo-700 dark:text-indigo-300">A = 1.20</h4>
                    <p class="text-sm">
                        Amplitudenfaktor der Î±(z)-Funktion
                    </p>
                </div>
                <div class="bg-indigo-50 dark:bg-indigo-900/20 p-3 rounded-lg">
                    <h4 class="font-semibold mb-1 text-indigo-700 dark:text-indigo-300">z* = 0.69</h4>
                    <p class="text-sm">
                        Ãœbergangszone zwischen kosmischen Epochen
                    </p>
                </div>
                <div class="bg-indigo-50 dark:bg-indigo-900/20 p-3 rounded-lg">
                    <h4 class="font-semibold mb-1 text-indigo-700 dark:text-indigo-300">Î² = 0.048</h4>
                    <p class="text-sm">
                        Kopplungsparameter an die Strukturentropie
                    </p>
                </div>
            </div>
            
            <div class="mt-4 p-3 bg-primary-50 dark:bg-primary-900/20 rounded-lg border-l-4 border-primary pulse-highlight">
                <p class="flex items-start">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-primary flex-shrink-0 mt-1" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>
                    <span>
                        Der Lambda-Term koppelt die Dunkle Energie an <strong class="font-semibold">zwei fundamentale thermodynamische GrÃ¶ÃŸen</strong>:
                        <ol class="list-decimal ml-5 mt-1 space-y-1">
                            <li><strong class="font-semibold">Temperatur der kosmischen Hintergrundstrahlung</strong> Ã¼ber den Term (Tâ‚€/T<sub>CMB</sub>)^Î±(z)</li>
                            <li><strong class="font-semibold">Strukturentropie</strong> Ã¼ber den Term (1 + Î²Â·S<sub>Struktur</sub>(z)/S<sub>Struktur</sub>(0))</li>
                        </ol>
                        Diese Kopplung erzeugt eine dynamische Dunkle Energie, die mit der kosmischen Entwicklung variiert.
                    </span>
                </p>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6">
                <div class="parameter-card p-4 bg-white dark:bg-gray-700 rounded-lg shadow">
                    <div class="formula-explainer">
                        <h4 class="text-lg font-semibold text-indigo-600 dark:text-indigo-300 mb-2 underline cursor-help">
                            Ãœbergangszone z<sub>*</sub>
                        </h4>
                        <div class="formula-tooltip">
                            Die Rotverschiebung, bei der die Temperaturkopplung ihr Verhalten Ã¤ndert
                        </div>
                    </div>
                    <p class="text-sm mb-2">
                        Legt fest, wann sich Î±(z) Ã¤ndert:
                    </p>
                    <input type="range" id="z_star" min="0.5" max="1.0" step="0.01" value="0.69" class="w-full">
                    <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400">
                        <span>FrÃ¼her (0.5)</span>
                        <span id="z_star_value" class="font-semibold text-black dark:text-white">z* = 0.69</span>
                        <span>SpÃ¤ter (1.0)</span>
                    </div>
                </div>
                
                <div class="parameter-card p-4 bg-white dark:bg-gray-700 rounded-lg shadow">
                    <div class="formula-explainer">
                        <h4 class="text-lg font-semibold text-indigo-600 dark:text-indigo-300 mb-2 underline cursor-help">
                            Basis-Exponent Î±<sub>0</sub>
                        </h4>
                        <div class="formula-tooltip">
                            Bestimmt die grundlegende StÃ¤rke und das Vorzeichen der Temperaturkopplung
                        </div>
                    </div>
                    <p class="text-sm mb-2">
                        Basiswert des Temperaturexponenten:
                    </p>
                    <input type="range" id="alpha_0" min="-1.0" max="1.0" step="0.05" value="-0.57" class="w-full">
                    <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400">
                        <span>SchwÃ¤chere DE (-1.0)</span>
                        <span id="alpha_0_value" class="font-semibold text-black dark:text-white">Î±â‚€ = -0.57</span>
                        <span>StÃ¤rkere DE (1.0)</span>
                    </div>
                </div>
                
                <div class="parameter-card p-4 bg-white dark:bg-gray-700 rounded-lg shadow">
                    <div class="formula-explainer">
                        <h4 class="text-lg font-semibold text-indigo-600 dark:text-indigo-300 mb-2 underline cursor-help">
                            Amplitudenfaktor A
                        </h4>
                        <div class="formula-tooltip">
                            Kontrolliert die StÃ¤rke des Ãœbergangs bei z*
                        </div>
                    </div>
                    <p class="text-sm mb-2">
                        StÃ¤rke des Ãœbergangs bei z<sub>*</sub>:
                    </p>
                    <input type="range" id="alpha_amp" min="0.5" max="2.0" step="0.05" value="1.20" class="w-full">
                    <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400">
                        <span>Schwach (0.5)</span>
                        <span id="alpha_amp_value" class="font-semibold text-black dark:text-white">A = 1.20</span>
                        <span>Stark (2.0)</span>
                    </div>
                </div>
            </div>
            
            <div class="mt-4 flex justify-center space-x-4">
                <button id="resetParams" class="px-3 py-1 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 text-sm flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Optimale Parameter
                </button>
                <button id="showLCDM" class="px-3 py-1 bg-cosmological text-white rounded-full hover:bg-opacity-90 text-sm flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Î›CDM Vergleich
                </button>
            </div>
        </section>

        <section class="bg-white/80 dark:bg-gray-800/80 p-6 rounded-xl shadow-lg mb-10">
            <h3 class="text-xl font-semibold mb-4 text-center text-indigo-600 dark:text-indigo-400 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                </svg>
                Dynamischer Î›(z)-Term und seine Evolution
            </h3>
            
            <div class="chart-container mb-6">
                <canvas id="LambdaMainChart"></canvas>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-primary-50 dark:bg-primary-900/20 p-4 rounded-lg border-l-4 border-primary">
                    <h4 class="text-lg font-semibold mb-3 text-primary dark:text-blue-300">GDE-Modell vs. Î›CDM</h4>
                    <ul class="space-y-2 list-disc pl-5">
                        <li><strong>Standardmodell:</strong> Î› ist eine Konstante (horizontale Linie).</li>
                        <li><strong>GDE-Modell:</strong> Î›(z) variiert mit der Rotverschiebung, abhÃ¤ngig von den thermodynamischen Bedingungen.</li>
                        <li><strong>Verhalten:</strong> Bei hohen z ist Î›(z) grÃ¶ÃŸer, nimmt dann ab und kann in der Zukunft wieder ansteigen.</li>
                        <li><strong>Normierung:</strong> Bei z=0 (heute) sind beide Modelle identisch (Î›â‚€ â‰ˆ 0.7).</li>
                    </ul>
                </div>
                
                <div class="bg-indigo-50 dark:bg-indigo-900/20 p-4 rounded-lg border-l-4 border-indigo-500">
                    <h4 class="text-lg font-semibold mb-3 text-indigo-600 dark:text-indigo-300">Physikalische Bedeutung</h4>
                    <ul class="space-y-2 list-disc pl-5">
                        <li><strong>FrÃ¼he Epoche (z > z*):</strong> HÃ¶here Î›(z)-Werte â†’ schwÃ¤chere Beschleunigung</li>
                        <li><strong>Ãœbergangsphase (z â‰ˆ z*):</strong> Ã„nderung des Î±(z)-Vorzeichens â†’ Ã„nderung des Î›(z)-Verhaltens</li>
                        <li><strong>SpÃ¤te Epoche (z < z*):</strong> Strukturentropie wird wichtiger â†’ modifiziert die reine Temperaturentwicklung</li>
                        <li><strong>Zukunft (z < 0):</strong> MÃ¶gliche Phantomphase mit steigendem Î›(z)</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
            <div class="bg-white/80 dark:bg-gray-800/80 p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-semibold mb-4 text-center text-indigo-600 dark:text-indigo-400 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z" />
                    </svg>
                    Temperaturkopplung im Î›(z)-Term
                </h3>
                <div class="small-chart-container">
                    <canvas id="TemperatureChart"></canvas>
                </div>
                <div class="mt-4 p-3 bg-purple-50 dark:bg-purple-900/30 rounded-lg">
                    <h4 class="font-semibold text-purple-800 dark:text-purple-200 mb-1">TemperaturabhÃ¤ngigkeit</h4>
                    <p class="text-sm">
                        Der Term (Tâ‚€/T<sub>CMB</sub>(z))^Î±(z) beschreibt, wie die Dunkle Energie an die kosmische Temperatur gekoppelt ist:
                    </p>
                    <ul class="text-sm mt-2 ml-4 space-y-1 list-disc">
                        <li>T<sub>CMB</sub>(z) = Tâ‚€(1+z) steigt linear mit z</li>
                        <li>Î±(z) moduliert Ã¼ber die Tanh-Funktion den Einfluss der Temperatur</li>
                        <li>Das Vorzeichen von Î±(z) bestimmt, ob Î›(z) mit steigender Temperatur zu- oder abnimmt</li>
                    </ul>
                </div>
            </div>

            <div class="bg-white/80 dark:bg-gray-800/80 p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-semibold mb-4 text-center text-indigo-600 dark:text-indigo-400 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                    Entropiekopplung im Î›(z)-Term
                </h3>
                <div class="small-chart-container">
                    <canvas id="EntropyChart"></canvas>
                </div>
                <div class="mt-4 p-3 bg-pink-50 dark:bg-pink-900/30 rounded-lg">
                    <h4 class="font-semibold text-pink-800 dark:text-pink-200 mb-1">Strukturentropie-Einfluss</h4>
                    <p class="text-sm">
                        Der Term (1 + Î²Â·S<sub>Struktur</sub>(z)/S<sub>Struktur</sub>(0)) verknÃ¼pft die Dunkle Energie mit der kosmischen Strukturbildung:
                    </p>
                    <ul class="text-sm mt-2 ml-4 space-y-1 list-disc">
                        <li>S<sub>Struktur</sub> steigt exponentiell mit abnehmender Rotverschiebung</li>
                        <li>Der Parameter Î² = 0.048 quantifiziert die StÃ¤rke dieser Kopplung</li>
                        <li>Je mehr Strukturen sich bilden, desto stÃ¤rker wird dieser Einfluss</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="bg-white/80 dark:bg-gray-800/80 p-6 rounded-xl shadow-lg mb-10">
            <h3 class="text-xl font-semibold mb-6 text-indigo-600 dark:text-indigo-400 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Die Komponenten von Î›(z) und ihre individuelle Entwicklung
            </h3>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div class="highlight-box temperature-box">
                    <h4 class="text-lg font-semibold mb-2 text-temperature">Temperatur-Term</h4>
                    <h5 class="font-mono font-semibold">(Tâ‚€/T<sub>CMB</sub>(z))^Î±(z)</h5>
                    <div class="mini-chart-container mt-3">
                        <canvas id="temperatureTermChart"></canvas>
                    </div>
                    <p class="text-sm mt-3">
                        Dieser Term beschreibt, wie die Dunkle Energie an die Temperatur der kosmischen Mikrowellenhintergrundstrahlung 
                        gekoppelt ist. Der Term wird durch den dynamischen Exponenten Î±(z) moduliert.
                    </p>
                </div>

                <div class="highlight-box entropy-box">
                    <h4 class="text-lg font-semibold mb-2 text-entropy">Entropie-Term</h4>
                    <h5 class="font-mono font-semibold">1 + Î²Â·S<sub>rel</sub>(z)</h5>
                    <div class="mini-chart-container mt-3">
                        <canvas id="entropyTermChart"></canvas>
                    </div>
                    <p class="text-sm mt-3">
                        Dieser Term koppelt die Dunkle Energie an die Entropie kosmischer Strukturen. 
                        Die Strukturentropie nimmt mit abnehmender Rotverschiebung zu, 
                        da immer mehr Materie in gravitativ gebundene Strukturen (Galaxien, Cluster) kollabiert.
                    </p>
                </div>

                <div class="highlight-box combined-box">
                    <h4 class="text-lg font-semibold mb-2 text-primary">Kombinierter Term</h4>
                    <h5 class="font-mono font-semibold">Î›(z) / Î›â‚€</h5>
                    <div class="mini-chart-container mt-3">
                        <canvas id="combinedTermChart"></canvas>
                    </div>
                    <p class="text-sm mt-3">
                        Der vollstÃ¤ndige Î›(z)-Term ergibt sich aus dem Produkt des Temperatur- und Entropieterms.
                        Diese Kombination fÃ¼hrt zu einer komplexen Dynamik, die die beobachtete w(z)-Evolution 
                        erklÃ¤rt und mit den DESI-Daten Ã¼bereinstimmt.
                    </p>
                </div>
            </div>

            <div class="p-4 border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-50 dark:bg-gray-800">
                <p class="text-center">
                    Die komplexe Dynamik von Î›(z) im GDE-Modell entsteht durch das <strong>Zusammenspiel</strong> der 
                    Temperaturkopplung und der Strukturentropie. Im Gegensatz zum Standardmodell (Î›CDM) ist Î› 
                    <strong>keine Konstante</strong>, sondern reagiert auf thermodynamische VerÃ¤nderungen im Universum.
                </p>
            </div>
        </section>

        <section class="bg-white/80 dark:bg-gray-800/80 p-6 rounded-xl shadow-lg mb-10">
            <h3 class="text-xl font-semibold mb-6 text-indigo-600 dark:text-indigo-400 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                </svg>
                Zusammenhang zwischen Î›(z) und w(z)
            </h3>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <div class="chart-container">
                    <canvas id="LambdaWzChart"></canvas>
                </div>
                
                <div class="p-4 bg-indigo-50 dark:bg-indigo-900/20 rounded-lg">
                    <h4 class="font-semibold text-indigo-600 dark:text-indigo-300 mb-2">Die mathematische Beziehung</h4>
                    <div class="equation-container">
                        <div class="equation-content text-center">
                            \[ w(z) = -1 + \frac{1+z}{3} \frac{d\ln\Lambda(z)}{dz} \]
                        </div>
                    </div>
                    <p class="text-sm mt-3">
                        Der Zustandsgleichungsparameter w(z) hÃ¤ngt direkt von der Ableitung von Î›(z) ab:
                    </p>
                    <ul class="mt-3 space-y-2">
                        <li class="flex items-start">
                            <svg class="h-5 w-5 text-indigo-500 mr-2 mt-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            <span>Bei <strong>steigendem Î›(z)</strong> (positive Ableitung) ist <strong>w(z) < -1</strong> (Phantom-Bereich)</span>
                        </li>
                        <li class="flex items-start">
                            <svg class="h-5 w-5 text-indigo-500 mr-2 mt-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            <span>Bei <strong>konstantem Î›(z)</strong> (Ableitung = 0) ist <strong>w(z) = -1</strong> (Î›CDM)</span>
                        </li>
                        <li class="flex items-start">
                            <svg class="h-5 w-5 text-indigo-500 mr-2 mt-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            <span>Bei <strong>fallendem Î›(z)</strong> (negative Ableitung) ist <strong>w(z) > -1</strong> (Quintessenz-Bereich)</span>
                        </li>
                    </ul>
                    <p class="text-sm mt-3">
                        Die thermodynamischen Kopplungen im GDE-Modell erzeugen eine komplexe Î›(z)-Dynamik, die zu 
                        unterschiedlichen w(z)-Werten fÃ¼hrt â€“ einschlieÃŸlich des von DESI gemessenen Wertes w(z=0.5) â‰ˆ -0.84.
                    </p>
                </div>
            </div>
        </section>

        <div class="text-center mt-8 p-4 bg-gradient-to-r from-white to-lightAccent dark:from-gray-900 dark:to-darkAccent rounded-lg shadow">
            <h3 class="text-xl font-semibold mb-3 text-primary">Zusammenfassung</h3>
            <p class="text-gray-700 dark:text-gray-300">
                Der dynamische Lambda-Term Î›(z) des GDE-Modells koppelt die Dunkle Energie an die kosmische Temperatur 
                und Strukturentropie. Diese thermodynamische Formulierung erzeugt eine natÃ¼rliche Dynamik, die die 
                beobachtete kosmische Entwicklung erklÃ¤rt, einschlieÃŸlich der von DESI gemessenen Abweichungen vom Î›CDM-Modell.
            </p>
            <p class="text-sm mt-4 text-gray-600 dark:text-gray-400">
                <span id="generationDate" class="font-semibold"></span>
            </p>
        </div>

        <footer class="mt-12 pt-8 border-t border-gray-300 dark:border-gray-700 italic text-center bg-gradient-to-br from-lightAccent to-white dark:from-darkAccent dark:to-gray-900 p-6 rounded-lg shadow-md">
            <p class="text-accent2 dark:text-accent3 font-serif">"Die beste Theorie ist nicht die komplizierteste, sondern die, die das Unerwartete einfach erklÃ¤rt." <span class="block mt-2 text-sm">-- Gabriel Ï•</span></p>
        </footer>
    </div>

    <script>
        // --- Data Generation based on GDE Model ---
        function generateData() {
            // Generate a detailed redshift range
            const zRange = [];
            const zStep = 0.05;
            for (let z = -0.5; z <= 3; z += zStep) { // Include negative z for future evolution
                zRange.push(parseFloat(z.toFixed(2)));
            }

            // Model parameters (optimal values from MCMC fit)
            const modelParams = {
                z_star: 0.69,
                alpha_0: -0.57,
                alpha_amp: 1.20,
                beta: 0.048
            };

            // Calculate Î±(z) according to tanh formula
            const alpha_z = zRange.map(z => {
                return modelParams.alpha_0 + modelParams.alpha_amp * Math.tanh(2 * (z - modelParams.z_star));
            });

            // Model for structure entropy ratio S_rel(z)
            const zData = [0.0, 0.5, 1.0, 2.0, 3.0];
            const sRelData = [1.0, 0.339, 0.156, 0.053, 0.02];
            
            // Interpolate S_rel for all z values
            const S_rel = zRange.map(z => {
                // Simple linear interpolation
                if (z < 0) return 1.0; // Assume future value same as today
                if (z > 3) return 0.02; // Assume distant past same as z=3
                
                // Find bracketing indices
                let i = 0;
                while (i < zData.length - 1 && zData[i + 1] < z) i++;
                
                if (i === zData.length - 1) return sRelData[i];
                if (z === zData[i]) return sRelData[i];
                
                // Linear interpolation formula
                const t = (z - zData[i]) / (zData[i + 1] - zData[i]);
                return sRelData[i] + t * (sRelData[i + 1] - sRelData[i]);
            });
            
            // Calculate temperature term: (Tâ‚€/T_CMB(z))^Î±(z)
            const tempTerm = zRange.map((z, i) => {
                // T_CMB(z) = Tâ‚€(1+z)
                // So Tâ‚€/T_CMB(z) = 1/(1+z)
                return Math.pow(1/(1+z), alpha_z[i]);
            });
            
            // Calculate entropy term: 1 + Î²Â·S_rel(z)
            const entropyTerm = zRange.map((z, i) => {
                return 1 + modelParams.beta * S_rel[i];
            });
            
            // Calculate Lambda(z)/Lambdaâ‚€ = Temperature term Ã— Entropy term
            const Lambda_ratio = zRange.map((z, i) => {
                return tempTerm[i] * entropyTerm[i];
            });
            
            // Î›CDM reference (constant Lambda)
            const Lambda_LCDM = Array(zRange.length).fill(1.0); // Normalized to Lambdaâ‚€
            
            // Calculate dlnLambda/dz for w(z) calculation
            const dlnLambda_dz = zRange.map((z, i, arr) => {
                if (i === 0) {
                    return Math.log(Lambda_ratio[i+1] / Lambda_ratio[i]) / zStep;
                } else if (i === arr.length - 1) {
                    return Math.log(Lambda_ratio[i] / Lambda_ratio[i-1]) / zStep;
                } else {
                    return Math.log(Lambda_ratio[i+1] / Lambda_ratio[i-1]) / (2 * zStep);
                }
            });
            
            // Calculate w(z) using the formula: w(z) = -1 + (1+z)/3 * dlnLambda/dz
            const w_z = zRange.map((z, i) => {
                return -1 + (1+z)/3 * dlnLambda_dz[i];
            });
            
            // w(z) for Î›CDM (constant Lambda)
            const w_z_LCDM = Array(zRange.length).fill(-1);

            return {
                z: zRange,
                alpha_z,
                S_rel,
                beta: modelParams.beta,
                tempTerm,
                entropyTerm,
                Lambda_ratio,
                Lambda_LCDM,
                w_z,
                w_z_LCDM,
                metadata: {
                    Lambda_0: 0.7, // Assume Lambda_0 = 0.7 for normalization
                    DESI_w_target: -0.84 // DESI measured value at z=0.5
                }
            };
        }
        
        // Generate the data
        const html_data = generateData();
        
        // Model parameters that can be adjusted by the user
        let modelParams = {
            z_star: 0.69,
            alpha_0: -0.57,
            alpha_amp: 1.20,
            beta: 0.048
        };
        
        // Chart instances
        let lambdaMainChartInstance, temperatureChartInstance, entropyChartInstance;
        let tempTermChartInstance, entropyTermChartInstance, combinedTermChartInstance;
        let lambdaWzChartInstance;
        
        // Function to recompute the data based on adjusted parameters
        function recomputeData() {
            // Get current parameters
            const z_star = modelParams.z_star;
            const alpha_0 = modelParams.alpha_0;
            const alpha_amp = modelParams.alpha_amp;
            const beta = modelParams.beta;
            
            // Recalculate alpha_z with new parameters
            html_data.alpha_z = html_data.z.map(z => {
                return alpha_0 + alpha_amp * Math.tanh(2 * (z - z_star));
            });
            
            // Recalculate temperature term
            html_data.tempTerm = html_data.z.map((z, i) => {
                return Math.pow(1/(1+z), html_data.alpha_z[i]);
            });
            
            // Recalculate entropy term
            html_data.entropyTerm = html_data.z.map((z, i) => {
                return 1 + beta * html_data.S_rel[i];
            });
            
            // Recalculate Lambda_ratio
            html_data.Lambda_ratio = html_data.z.map((z, i) => {
                return html_data.tempTerm[i] * html_data.entropyTerm[i];
            });
            
            // Recalculate dlnLambda_dz
            const zStep = html_data.z[1] - html_data.z[0];
            const dlnLambda_dz = html_data.z.map((z, i, arr) => {
                if (i === 0) {
                    return Math.log(html_data.Lambda_ratio[i+1] / html_data.Lambda_ratio[i]) / zStep;
                } else if (i === arr.length - 1) {
                    return Math.log(html_data.Lambda_ratio[i] / html_data.Lambda_ratio[i-1]) / zStep;
                } else {
                    return Math.log(html_data.Lambda_ratio[i+1] / html_data.Lambda_ratio[i-1]) / (2 * zStep);
                }
            });
            
            // Recalculate w(z)
            html_data.w_z = html_data.z.map((z, i) => {
                return -1 + (1+z)/3 * dlnLambda_dz[i];
            });
        }
        
        // Function to create chart options based on dark mode
        function getChartOptions(titleText, yLabel, additionalOptions = {}) {
            const isDarkMode = document.documentElement.classList.contains('dark');
            const textColor = isDarkMode ? '#f3f4f6' : '#1f2937';
            const gridColor = isDarkMode ? 'rgba(209, 213, 219, 0.2)' : 'rgba(55, 65, 81, 0.2)';
            const tooltipBgColor = isDarkMode ? 'rgba(55, 65, 81, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            
            const baseOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 1000,
                    easing: 'easeOutQuart'
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { 
                            color: textColor,
                            usePointStyle: true,
                            boxWidth: 6,
                            font: { size: 11 }
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: tooltipBgColor,
                        titleColor: textColor,
                        bodyColor: textColor,
                        borderColor: isDarkMode ? '#4b5563' : '#e5e7eb',
                        borderWidth: 1,
                        padding: 10,
                        titleFont: { size: 13, weight: 'bold' },
                        bodyFont: { size: 12 },
                        displayColors: true,
                        boxWidth: 8,
                        boxHeight: 8,
                        cornerRadius: 4
                    },
                    title: {
                        display: false,
                        text: titleText,
                        color: textColor
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Rotverschiebung z',
                            color: textColor,
                            font: { weight: 'bold', size: 12 },
                            padding: { top: 10 }
                        },
                        ticks: { 
                            color: textColor,
                            font: { size: 11 }
                        },
                        grid: { 
                            color: gridColor,
                            drawBorder: false
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: yLabel,
                            color: textColor,
                            font: { weight: 'bold', size: 12 },
                            padding: { bottom: 10 }
                        },
                        ticks: { 
                            color: textColor,
                            font: { size: 11 }
                        },
                        grid: { 
                            color: gridColor,
                            drawBorder: false
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                elements: {
                    point: {
                        radius: 0,
                        hoverRadius: 5
                    },
                    line: {
                        tension: 0.4,
                        borderWidth: 3
                    }
                }
            };
            
            // Deep merge additional options (like y-axis type)
            if (additionalOptions.scales && additionalOptions.scales.y) {
                Object.assign(baseOptions.scales.y, additionalOptions.scales.y);
            }
            
            return baseOptions;
        }
        
        // Function to create gradient backgrounds for charts
        function createGradient(ctx, color1, color2, opacity1 = 0.7, opacity2 = 0.1) {
            const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
            gradient.addColorStop(0, `rgba(${hexToRgb(color1)}, ${opacity1})`);
            gradient.addColorStop(1, `rgba(${hexToRgb(color2)}, ${opacity2})`);
            return gradient;
        }
        
        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.replace('#', ''), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `${r}, ${g}, ${b}`;
        }
        
        // Find crossings with y=1 (Î›CDM)
        function findCrossings(dataArray) {
            const crossings = [];
            for (let i = 0; i < dataArray.length - 1; i++) {
                if ((dataArray[i] < 1 && dataArray[i+1] >= 1) || 
                    (dataArray[i] > 1 && dataArray[i+1] <= 1)) {
                    crossings.push(i);
                }
            }
            return crossings;
        }
        
        // Register annotation plugin
        function registerAnnotationPlugin() {
            Chart.register({
                id: 'customAnnotation',
                afterDraw: (chart, args, options) => {
                    if (!options || !options.annotations) return;
                    
                    const { ctx, chartArea, scales } = chart;
                    
                    options.annotations.forEach(annotation => {
                        if (!annotation.enabled) return;
                        
                        const x = scales.x.getPixelForValue(annotation.xValue);
                        const y = scales.y.getPixelForValue(annotation.yValue);
                        
                        // Draw circle at point
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, 2 * Math.PI);
                        ctx.fillStyle = annotation.backgroundColor || '#FF6384';
                        ctx.fill();
                        ctx.strokeStyle = annotation.borderColor || '#FF6384';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Add label
                        if (annotation.label) {
                            ctx.fillStyle = '#FFF';
                            ctx.font = 'bold 11px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(annotation.label, x, y);
                        }
                        
                        // Add description box
                        if (annotation.description) {
                            const textX = annotation.descriptionOffsetX ? x + annotation.descriptionOffsetX : x + 15;
                            const textY = annotation.descriptionOffsetY ? y + annotation.descriptionOffsetY : y - 15;
                            
                            ctx.font = '11px sans-serif';
                            ctx.textAlign = 'left';
                            
                            const textWidth = ctx.measureText(annotation.description).width;
                            const padding = 6;
                            
                            // Box with rounded corners
                            const boxHeight = 24;
                            const radius = 4;
                            
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.beginPath();
                            ctx.moveTo(textX - padding + radius, textY - 12);
                            ctx.lineTo(textX - padding + textWidth + padding * 2 - radius, textY - 12);
                            ctx.quadraticCurveTo(textX - padding + textWidth + padding * 2, textY - 12, textX - padding + textWidth + padding * 2, textY - 12 + radius);
                            ctx.lineTo(textX - padding + textWidth + padding * 2, textY - 12 + boxHeight - radius);
                            ctx.quadraticCurveTo(textX - padding + textWidth + padding * 2, textY - 12 + boxHeight, textX - padding + textWidth + padding * 2 - radius, textY - 12 + boxHeight);
                            ctx.lineTo(textX - padding + radius, textY - 12 + boxHeight);
                            ctx.quadraticCurveTo(textX - padding, textY - 12 + boxHeight, textX - padding, textY - 12 + boxHeight - radius);
                            ctx.lineTo(textX - padding, textY - 12 + radius);
                            ctx.quadraticCurveTo(textX - padding, textY - 12, textX - padding + radius, textY - 12);
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.fillStyle = '#1F2937';
                            ctx.fillText(annotation.description, textX, textY);
                        }
                        
                        ctx.restore();
                    });
                }
            });
        }
        
        // Function to render all charts
        function renderCharts() {
            // Register the annotation plugin
            registerAnnotationPlugin();
            
            // Find where Lambda(z) crosses Î›CDM value (Lambda_ratio = 1)
            const crossings = findCrossings(html_data.Lambda_ratio);
            
            // Main Lambda(z) Chart
            const lambdaMainCtx = document.getElementById('LambdaMainChart').getContext('2d');
            if (lambdaMainChartInstance) lambdaMainChartInstance.destroy();
            
            lambdaMainChartInstance = new Chart(lambdaMainCtx, {
                type: 'line',
                data: {
                    labels: html_data.z,
                    datasets: [
                        {
                            label: 'Î›(z)/Î›â‚€ GDE-Modell',
                            data: html_data.Lambda_ratio,
                            borderColor: '#5D5CDE', // Primary
                            backgroundColor: createGradient(lambdaMainCtx, '#5D5CDE', '#5D5CDE'),
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 5
                        },
                        {
                            label: 'Î› Î›CDM-Modell (konstant)',
                            data: html_data.Lambda_LCDM,
                            borderColor: '#10b981', // Cosmological green
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            tension: 0,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }
                    ]
                },
                options: {
                    ...getChartOptions('Lambda-Term Î›(z)/Î›â‚€', 'Î›(z)/Î›â‚€'),
                    plugins: {
                        ...getChartOptions().plugins,
                        tooltip: {
                            ...getChartOptions().plugins.tooltip,
                            callbacks: {
                                label: (context) => {
                                    const z = html_data.z[context.dataIndex];
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    
                                    let note = '';
                                    if (context.datasetIndex === 0) {
                                        if (value > 1) note = ' (hÃ¶her als Î›CDM)';
                                        else if (value < 1) note = ' (niedriger als Î›CDM)';
                                        else note = ' (identisch mit Î›CDM)';
                                    }
                                    
                                    return `${label}: ${value.toFixed(3)} bei z=${z}${note}`;
                                }
                            }
                        },
                        customAnnotation: {
                            annotations: [
                                {
                                    enabled: true,
                                    xValue: modelParams.z_star,
                                    yValue: html_data.Lambda_ratio[html_data.z.findIndex(z => z.toFixed(2) == modelParams.z_star.toFixed(2)) || 0],
                                    backgroundColor: '#5D5CDE',
                                    borderColor: '#4338ca',
                                    label: '',
                                    description: `Ãœbergangszone z* = ${modelParams.z_star.toFixed(2)}`
                                },
                                ...(crossings.map(i => ({
                                    enabled: true,
                                    xValue: html_data.z[i],
                                    yValue: 1, // crossing Î›CDM value
                                    backgroundColor: '#10b981',
                                    borderColor: '#059669',
                                    label: '',
                                    description: `Ãœbergang bei z â‰ˆ ${html_data.z[i].toFixed(2)}`
                                })))
                            ]
                        }
                    }
                }
            });

            // Temperature Component Chart
            const temperatureCtx = document.getElementById('TemperatureChart').getContext('2d');
            if (temperatureChartInstance) temperatureChartInstance.destroy();
            
            temperatureChartInstance = new Chart(temperatureCtx, {
                type: 'line',
                data: {
                    labels: html_data.z,
                    datasets: [
                        {
                            label: 'Temperatur-Term (Tâ‚€/T_CMB)^Î±(z)',
                            data: html_data.tempTerm,
                            borderColor: '#8b5cf6', // Violet
                            backgroundColor: createGradient(temperatureCtx, '#8b5cf6', '#8b5cf6'),
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 5
                        },
                        {
                            label: 'Î±(z)',
                            data: html_data.alpha_z,
                            borderColor: '#db2777', // Pink
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            tension: 0.4,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    ...getChartOptions('Temperatur-Kopplung', '(Tâ‚€/T_CMB)^Î±(z)'),
                    scales: {
                        ...getChartOptions().scales,
                        y: {
                            ...getChartOptions().scales.y,
                            title: {
                                ...getChartOptions().scales.y.title,
                                text: 'Temperatur-Term'
                            }
                        },
                        y1: {
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Î±(z)',
                                color: getChartOptions().scales.y.title.color,
                                font: getChartOptions().scales.y.title.font
                            },
                            ticks: getChartOptions().scales.y.ticks,
                            grid: {
                                ...getChartOptions().scales.y.grid,
                                display: false
                            }
                        }
                    },
                    plugins: {
                        ...getChartOptions().plugins,
                        tooltip: {
                            ...getChartOptions().plugins.tooltip,
                            callbacks: {
                                label: (context) => {
                                    const z = html_data.z[context.dataIndex];
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    
                                    if (context.datasetIndex === 0) {
                                        return `Temperatur-Term: ${value.toFixed(3)} bei z=${z}`;
                                    } else {
                                        return `Î±(${z}) = ${value.toFixed(3)}`;
                                    }
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                zeroLine: {
                                    type: 'line',
                                    yMin: 0,
                                    yMax: 0,
                                    borderColor: 'rgba(219, 39, 119, 0.5)',
                                    borderWidth: 1,
                                    borderDash: [4, 4],
                                    yScaleID: 'y1'
                                }
                            }
                        }
                    }
                }
            });

            // Entropy Component Chart
            const entropyCtx = document.getElementById('EntropyChart').getContext('2d');
            if (entropyChartInstance) entropyChartInstance.destroy();
            
            entropyChartInstance = new Chart(entropyCtx, {
                type: 'line',
                data: {
                    labels: html_data.z,
                    datasets: [
                        {
                            label: 'Entropie-Term (1 + Î²Â·S_rel)',
                            data: html_data.entropyTerm,
                            borderColor: '#db2777', // Pink
                            backgroundColor: createGradient(entropyCtx, '#db2777', '#db2777'),
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 5
                        },
                        {
                            label: 'S_rel(z)',
                            data: html_data.S_rel,
                            borderColor: '#8b5cf6', // Violet
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            tension: 0.4,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    ...getChartOptions('Entropie-Kopplung', '1 + Î²Â·S_rel(z)'),
                    scales: {
                        ...getChartOptions().scales,
                        y: {
                            ...getChartOptions().scales.y,
                            title: {
                                ...getChartOptions().scales.y.title,
                                text: 'Entropie-Term'
                            }
                        },
                        y1: {
                            position: 'right',
                            title: {
                                display: true,
                                text: 'S_rel(z)',
                                color: getChartOptions().scales.y.title.color,
                                font: getChartOptions().scales.y.title.font
                            },
                            ticks: getChartOptions().scales.y.ticks,
                            grid: {
                                ...getChartOptions().scales.y.grid,
                                display: false
                            },
                            min: 0,
                            max: 1.1
                        }
                    },
                    plugins: {
                        ...getChartOptions().plugins,
                        tooltip: {
                            ...getChartOptions().plugins.tooltip,
                            callbacks: {
                                label: (context) => {
                                    const z = html_data.z[context.dataIndex];
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    
                                    if (context.datasetIndex === 0) {
                                        return `Entropie-Term: ${value.toFixed(3)} bei z=${z}`;
                                    } else {
                                        return `S_rel(${z}) = ${value.toFixed(3)}`;
                                    }
                                }
                            }
                        }
                    }
                }
            });
            
            // Mini charts for the components
            renderMiniCharts();
            
            // Lambda vs w(z) Chart
            const lambdaWzCtx = document.getElementById('LambdaWzChart').getContext('2d');
            if (lambdaWzChartInstance) lambdaWzChartInstance.destroy();
            
            lambdaWzChartInstance = new Chart(lambdaWzCtx, {
                type: 'line',
                data: {
                    labels: html_data.z,
                    datasets: [
                        {
                            label: 'Î›(z)/Î›â‚€',
                            data: html_data.Lambda_ratio,
                            borderColor: '#5D5CDE', // Primary
                            backgroundColor: 'transparent',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 5,
                            yAxisID: 'y'
                        },
                        {
                            label: 'w(z)',
                            data: html_data.w_z,
                            borderColor: '#db2777', // Pink
                            backgroundColor: 'transparent',
                            borderWidth: 2.5,
                            borderDash: [5, 5],
                            tension: 0.4,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 5,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    ...getChartOptions('', ''),
                    scales: {
                        x: {
                            ...getChartOptions().scales.x
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Î›(z)/Î›â‚€',
                                color: getChartOptions().scales.y.title.color,
                                font: getChartOptions().scales.y.title.font
                            },
                            ticks: getChartOptions().scales.y.ticks,
                            grid: {
                                ...getChartOptions().scales.y.grid,
                                display: true
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'w(z)',
                                color: getChartOptions().scales.y.title.color,
                                font: getChartOptions().scales.y.title.font
                            },
                            ticks: getChartOptions().scales.y.ticks,
                            grid: {
                                ...getChartOptions().scales.y.grid,
                                display: false
                            },
                            min: -1.3,
                            max: -0.7
                        }
                    },
                    plugins: {
                        ...getChartOptions().plugins,
                        tooltip: {
                            ...getChartOptions().plugins.tooltip,
                            callbacks: {
                                label: (context) => {
                                    const z = html_data.z[context.dataIndex];
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    
                                    if (context.dataset.yAxisID === 'y') {
                                        return `Î›(${z})/Î›â‚€ = ${value.toFixed(3)}`;
                                    } else {
                                        let regime = '';
                                        if (value < -1) regime = ' (Phantom-Bereich)';
                                        else if (value > -1) regime = ' (Quintessenz-Bereich)';
                                        else regime = ' (Î›CDM)';
                                        
                                        return `w(${z}) = ${value.toFixed(3)}${regime}`;
                                    }
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                lcdmLineY: {
                                    type: 'line',
                                    yMin: 1,
                                    yMax: 1,
                                    borderColor: 'rgba(16, 185, 129, 0.5)',
                                    borderWidth: 1.5,
                                    borderDash: [2, 2]
                                },
                                lcdmLineY1: {
                                    type: 'line',
                                    yMin: -1,
                                    yMax: -1,
                                    borderColor: 'rgba(219, 39, 119, 0.5)',
                                    borderWidth: 1.5,
                                    borderDash: [2, 2],
                                    yScaleID: 'y1'
                                },
                                desiPoint: {
                                    type: 'point',
                                    xValue: 0.5,
                                    yValue: html_data.metadata.DESI_w_target,
                                    backgroundColor: 'rgba(249, 115, 22, 0.7)',
                                    radius: 6,
                                    yScaleID: 'y1'
                                },
                                desiLabel: {
                                    type: 'label',
                                    xValue: 0.5,
                                    yValue: -0.77,
                                    content: 'DESI: w(0.5) = -0.84',
                                    font: {
                                        size: 11,
                                        weight: 'bold'
                                    },
                                    color: '#f97316',
                                    yScaleID: 'y1'
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Function to render mini charts for the components
        function renderMiniCharts() {
            // Temperature term mini chart
            const tempTermCtx = document.getElementById('temperatureTermChart').getContext('2d');
            if (tempTermChartInstance) tempTermChartInstance.destroy();
            
            tempTermChartInstance = new Chart(tempTermCtx, {
                type: 'line',
                data: {
                    labels: html_data.z,
                    datasets: [{
                        label: '(Tâ‚€/T_CMB)^Î±(z)',
                        data: html_data.tempTerm,
                        borderColor: '#8b5cf6',
                        backgroundColor: 'rgba(139, 92, 246, 0.2)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    },
                    elements: {
                        point: {
                            radius: 0
                        }
                    }
                }
            });
            
            // Entropy term mini chart
            const entropyTermCtx = document.getElementById('entropyTermChart').getContext('2d');
            if (entropyTermChartInstance) entropyTermChartInstance.destroy();
            
            entropyTermChartInstance = new Chart(entropyTermCtx, {
                type: 'line',
                data: {
                    labels: html_data.z,
                    datasets: [{
                        label: '1 + Î²Â·S_rel(z)',
                        data: html_data.entropyTerm,
                        borderColor: '#db2777',
                        backgroundColor: 'rgba(219, 39, 119, 0.2)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    },
                    elements: {
                        point: {
                            radius: 0
                        }
                    }
                }
            });
            
            // Combined term mini chart
            const combinedTermCtx = document.getElementById('combinedTermChart').getContext('2d');
            if (combinedTermChartInstance) combinedTermChartInstance.destroy();
            
            combinedTermChartInstance = new Chart(combinedTermCtx, {
                type: 'line',
                data: {
                    labels: html_data.z,
                    datasets: [{
                        label: 'Î›(z)/Î›â‚€',
                        data: html_data.Lambda_ratio,
                        borderColor: '#5D5CDE',
                        backgroundColor: 'rgba(93, 92, 222, 0.2)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    },
                    elements: {
                        point: {
                            radius: 0
                        }
                    }
                }
            });
        }
        
        // Set up interactive parameter controls
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize sliders
            const z_starSlider = document.getElementById('z_star');
            const z_starValue = document.getElementById('z_star_value');
            const alpha_0Slider = document.getElementById('alpha_0');
            const alpha_0Value = document.getElementById('alpha_0_value');
            const alpha_ampSlider = document.getElementById('alpha_amp');
            const alpha_ampValue = document.getElementById('alpha_amp_value');
            const resetButton = document.getElementById('resetParams');
            const showLCDMButton = document.getElementById('showLCDM');
            
            if (z_starSlider) {
                z_starSlider.addEventListener('input', function(e) {
                    const value = parseFloat(e.target.value);
                    z_starValue.textContent = `z* = ${value.toFixed(2)}`;
                    modelParams.z_star = value;
                    recomputeData();
                    renderCharts();
                });
            }
            
            if (alpha_0Slider) {
                alpha_0Slider.addEventListener('input', function(e) {
                    const value = parseFloat(e.target.value);
                    alpha_0Value.textContent = `Î±â‚€ = ${value.toFixed(2)}`;
                    modelParams.alpha_0 = value;
                    recomputeData();
                    renderCharts();
                });
            }
            
            if (alpha_ampSlider) {
                alpha_ampSlider.addEventListener('input', function(e) {
                    const value = parseFloat(e.target.value);
                    alpha_ampValue.textContent = `A = ${value.toFixed(2)}`;
                    modelParams.alpha_amp = value;
                    recomputeData();
                    renderCharts();
                });
            }
            
            if (resetButton) {
                resetButton.addEventListener('click', function() {
                    // Reset to optimal values
                    modelParams = {
                        z_star: 0.69,
                        alpha_0: -0.57,
                        alpha_amp: 1.20,
                        beta: 0.048
                    };
                    
                    // Update slider positions and values
                    if (z_starSlider) {
                        z_starSlider.value = modelParams.z_star;
                        z_starValue.textContent = `z* = ${modelParams.z_star.toFixed(2)}`;
                    }
                    
                    if (alpha_0Slider) {
                        alpha_0Slider.value = modelParams.alpha_0;
                        alpha_0Value.textContent = `Î±â‚€ = ${modelParams.alpha_0.toFixed(2)}`;
                    }
                    
                    if (alpha_ampSlider) {
                        alpha_ampSlider.value = modelParams.alpha_amp;
                        alpha_ampValue.textContent = `A = ${modelParams.alpha_amp.toFixed(2)}`;
                    }
                    
                    // Recompute data and redraw charts
                    recomputeData();
                    renderCharts();
                });
            }
            
            if (showLCDMButton) {
                showLCDMButton.addEventListener('click', function() {
                    if (lambdaMainChartInstance) {
                        // Toggle visibility of Î›CDM line
                        const visible = lambdaMainChartInstance.isDatasetVisible(1);
                        lambdaMainChartInstance.setDatasetVisibility(1, !visible);
                        lambdaMainChartInstance.update();
                        
                        // Change button text
                        this.innerHTML = visible ? 
                            '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> Î›CDM anzeigen' : 
                            '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg> Î›CDM ausblenden';
                    }
                });
            }
            
            // --- Dark mode toggle ---
            const darkModeToggle = document.getElementById('darkModeToggle');
            const darkModeIcon = document.getElementById('darkModeIcon');
            const darkModeText = document.getElementById('darkModeText');
            
            function updateDarkModeUI() {
                if (document.documentElement.classList.contains('dark')) {
                    darkModeIcon.textContent = 'â˜€ï¸';
                    darkModeText.textContent = 'Light Mode';
                } else {
                    darkModeIcon.textContent = 'ðŸŒ™';
                    darkModeText.textContent = 'Dark Mode';
                }
            }
            
            function toggleDarkMode() {
                if (document.documentElement.classList.contains('dark')) {
                    document.documentElement.classList.remove('dark');
                } else {
                    document.documentElement.classList.add('dark');
                }
                
                updateDarkModeUI();
                renderCharts();
            }
            
            if (darkModeToggle) {
                darkModeToggle.addEventListener('click', toggleDarkMode);
                updateDarkModeUI();
            }
            
            // Set generation date
            document.getElementById('generationDate').textContent = `Daten generiert am: ${new Date().toLocaleDateString('de-DE', {
                year: 'numeric', month: 'long', day: 'numeric'
            })}`;
            
            // --- Loading indicator ---
            const loadingBar = document.getElementById('loading-bar');
            function updateLoadingBar(percent) {
                loadingBar.style.width = `${percent}%`;
                if (percent >= 100) {
                    setTimeout(() => {
                        loadingBar.style.width = '0%';
                    }, 300);
                }
            }
            
            // Simulate loading progress
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += 5;
                updateLoadingBar(progress);
                if (progress >= 100) {
                    clearInterval(loadingInterval);
                }
            }, 50);
            
            // Initial render
            renderCharts();
        });
        
        // Ensure MathJax is properly initialized
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']]
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    setTimeout(renderCharts, 200);
                }
            }
        };
    </script>
</body>
</html>
